<!DOCTYPE html>
<html lang="en">
<head>
  <title>Testing Farm Result</title>
  <meta charset="utf-8">

  <style>
    header {
        display: flex;
        align-items: center;
        gap: 2ex;
    }
    .stretch { flex: auto; }
    #config {
        padding: 1em 0.5em;
        border: lightgray;
        border-width: 1px;
        border-style: solid;
        box-shadow: 2px 2px 2px lightgrey;
    }

    details {
      padding: 1ex;
      margin: 3ex;
      background-color: #F2F2F2;
      box-shadow: 2px 2px 2px lightgrey;
    }
    details > summary {
        padding: 1.5em;
        font-family: monospace;
    }
    monospace {
        font-family: monospace;
        font-size: 11px;
    }
    details > summary > p {
        margin-bottom: 0;
        font-weight: bold;
    }

    /* nested details are testcases in a testsuite */
    details details { background-color: white; }
    details details > summary { padding: 0.5em; }
    /* nested details in testcases are checks */
    details details details { background-color: #F2F2F2; }
    details details details > summary { padding: 0.1em; }
    details details details details { background-color: white; }

    .result-pass { background-color: lightgreen; font-size: 12px; }
    .result-fail { background-color: #ff4d4d; font-size: 12px; }
    .result-info { background-color: lightblue; font-size: 12px; }
    .result-skip { background-color: lightgrey; font-size: 12px; }
    .result-error { background-color: darkorange; font-size: 12px; }
    .result-running { background-color: paleturquoise; font-size: 12px; }
    .result-warn { background-color: khaki; font-size: 12px; }
    .footer { color:#929292; }
    .subresult { padding: 1ex; margin: 3ex; background-color: white; box-shadow: 2px 2px 2px lightgrey; }
    .notes { margin-top: 0px; margin-bottom: 0px; padding-left: 0px; }
    .highlight { outline-style: solid; outline-color: navy; }
    .anchor { text-decoration: none; color: inherit }
    .anchor:hover { text-decoration: underline; }

    iframe.html-artifact { height: 80vh; }
  </style>
</head>

<body>
  <header>
    <img src="https://gitlab.com/uploads/-/system/group/avatar/5515434/tft-logo.png"
        width="64" height="64" alt="Testing Farm Logo"/>
    <h1 id="overall-result"></h1>
    <div id="config" hidden>
        <input id="show_passed" type="checkbox" />
        <label for="show_passed">Show passed tests</label>
    </div>
    <div class="stretch"></div>
    <a href="#" id="switchToNewUI" hidden>ðŸš€ Try New UI ðŸš€</a>
    <span id="switchToNewUISeparator" hidden>|</span>
    <a id="docs" hidden>Docs</a>
    <span id="docs-separator" hidden>|</span>
    <a id="api-request" hidden>API request</a>
    <span id="api-request-separator" hidden>|</span>
    <a id="pipeline-log">Pipeline log</a>
    <span id="download-junit-separator" hidden>|</span>
    <a id="download-junit" download hidden>Download JUnit</a>
  </header>

  <script>
    // Early redirect to next.html if preference is set and file exists
    (async () => {
        try {
            if (localStorage.getItem('oculusUIVersion') === 'next') {
                const response = await fetch('next.html', { method: 'HEAD' });
                if (response.ok) {
                    window.location.href = 'next.html';
                } else {
                    // If next.html is not found, clear the preference
                    localStorage.removeItem('oculusUIVersion');
                }
            }
        } catch (error) {
            console.warn('Error checking for next.html during early redirect:', error);
            // Potentially clear preference if fetch fails due to network or other issues
            localStorage.removeItem('oculusUIVersion');
        }
    })();
  </script>

  <main id="main"></main>

  <footer><hr><div class="footer">Rendered from: <a id="results-xml-src"></a> by <a href="https://gitlab.com/testing-farm/oculus">Oculus</a></div></footer>
</body>

<script type="module">
import {
    LitElement, html, unsafeHTML, css, render, nothing
} from 'https://cdn.jsdelivr.net/gh/lit/dist@2/all/lit-all.min.js';
import { AnsiUp } from 'https://cdn.jsdelivr.net/npm/ansi_up@6.0.2/ansi_up.js';

const ansiUp = new AnsiUp();

const SHOW_ATTR = '_show'; /* marks logs which are shown inline */
const HTML_ATTR = '_html'; /* marks HTML artifacts which are shown inline */

const isPassed = result => result.includes('pass');

// If number of testcases is bigger then the value, both testsuites and
// testcases will be collapsed.
const tooManyTestcases = 2;

// HACK: the request API url should be read from some metadata file instead
const apiUrl = 'https://api.testing-farm.io/v0.1/requests';

const uuidRegex = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/;

// allow user to point to a different result URL, mostly for testing
const baseUrl = new URLSearchParams(window.location.search).get('url') ?? '.';

// pipeline log, the main log of the worker
const pipelineLogUrl = `${baseUrl}/pipeline.log`;

// link to the user docs
const docsUrl = 'https://docs.testing-farm.io/Testing%20Farm/0.1/index.html';

// scroll a linked element into view only once
let scrolledIntoView = false;

// HACK: Until TFT-1687 is implemented.
// unify the variations of "pass", "passed", "failed", "failure", etc. to the defined .result-.. classes
function normalizeResult (result, isPipelineRunning) {
    if (!result) {
        return 'error';
    }
    const lower = result.toLowerCase();
    if (lower.includes('pass')) { return 'pass' }
    if (lower.includes('fail') || lower.includes('inspection')) { return 'fail' }
    if (lower.includes('skip') || lower.includes('not_applicable')) { return 'skip' }
    if (lower.includes('info')) { return 'info' }
    if (lower.includes('pending') && isPipelineRunning) { return 'running' }
    if (lower.includes('pending')) { return 'error' }
    if (lower.includes('undefined') && isPipelineRunning) { return 'running' }
    // treat other values like "error", "undefined", unknown as generic error
    return 'error';
}

function stagePlaceholder (stage) {
    switch (stage) {
    case 'created':
    case 'ready':
        return 'Preparing to run';
    case 'guest_provisioning':
        return 'Provisioning in progress';
    case 'guest_provisioned':
    case 'guest_setup':
        return 'Test environment setup is in progress';
    case 'prepared':
    case 'running':
        return 'Tests are being executed';
    default:
        return 'Loading...';
    }
}

async function fetchFile (url, options) {
    try {
        const response = await fetch(url, options);
        if (response.ok) {
            return await response.text();
        } else {
            console.warn('Failed to fetch', url, ':', response.status, response.statusText);
        }
    } catch (error) {
        console.warn('Failed to fetch', url, ':', error);
    }
}

async function fetchHeader (url) {
    try {
        const response = await fetch(url, { method: 'HEAD' });
        if (response.ok) { return true }
    } catch (error) {
        console.warn('Failed to fetch header', url, ':', error);
    }
    return false;
}

async function fetchJSON (url) {
    try {
        const response = await fetch(url);
        if (response.ok) {
            return await response.json();
        } else {
            console.warn('Failed to fetch', url, ':', response.status, response.statusText);
        }
    } catch (error) {
        console.warn('Failed to fetch', url, ':', error);
    }
}

async function fetchXML (url) {
    const raw = await fetchFile(url);
    if (raw) { return new DOMParser().parseFromString(raw, 'text/xml') }
}

// custom component: dynamically load a log file/directory and show it inline
class LogViewer extends LitElement {
    static properties = {
        url: { type: String },
        placeholder: { type: String },
        _contents: { type: String, state: true },
        _loading: { type: Boolean }
    };

    updated (changedProperties) {
        if (changedProperties.has('url')) {
            fetchFile(this.url).then(text => {
                this._loading = true;
                if (text) {
                    // is this a directory index? if so, load all of its *.txt files and concatenate
                    if (text.includes('<title>Index of ')) {
                        const indexDoc = new DOMParser().parseFromString(text, 'text/html');
                        const fetches = [];
                        indexDoc.querySelectorAll('a[href*=".txt"]').forEach(link =>
                            fetches.push(fetchFile(this.url + '/' + link.getAttribute('href'))));
                        Promise.all(fetches).then(texts => { this._contents = texts.join('\n\n') });
                    } else {
                        // plain file
                        this._contents = text;
                    }
                } else {
                    // file doesn't exist or has no text
                    this._contents = null;
                }
                this._loading = false;
            });
        } else if (scrolledIntoView === false && changedProperties.has('_loading') && this._loading === false) {
            scrollIntoLinkedElement();
        }
    }

    render () {
        if (this._contents === null) {
            return html`<pre class="log-viewer">${this.placeholder}</pre>`;
        } else {
            return html`<pre class="log-viewer">${unsafeHTML(
                ansiUp.ansi_to_html(this._contents)) ?? 'Loading...'}</pre>`;
        }
    }

    static styles = css`
        pre {
            background-color: #E0E0E0;
            padding: 0.5em;
            overflow: auto;
            max-height: 70em;
        }`;
}

function scrollIntoLinkedElement () {
    const element = document.getElementById(window.location.hash.substring(1));
    if (!element) { return }
    scrolledIntoView = true;
    element.scrollIntoView();
}

customElements.define('log-viewer', LogViewer);

function renderLogs (logElements, artifactsAnchor, stage, result) {
    const logLinks = [];
    const inlineLogs = [];
    logElements.forEach(log => {
        let name = log.getAttribute('name');
        const href = log.getAttribute('href');
        if (!name) { name = href }
        const placeholder = stagePlaceholder(stage);
        // HACK: results.xml should have unique names; fix that, and then clean this up
        const setupStage = log.getAttribute('guest-setup-stage');
        if (setupStage && name === 'guest setup') { name = setupStage }
        if (log.hasAttribute(SHOW_ATTR)) {
            inlineLogs.push(html`<h3><a href=${href}>${name}</a></h3>
                                 <log-viewer placeholder=${placeholder} url=${href} />`);
        } else if (log.hasAttribute(HTML_ATTR)) {
            inlineLogs.push(html`<h3><a href=${href}>${name}</a></h3>
                                 <iframe class="html-artifact" title=${name} src=${href} width="100%" />`);
        } else {
            logLinks.push(html`<li><a href=${href}>${name}</a></li>`);
        }
    });

    // no logs can mean an infrastructure problem, provide some hints how to handle the situation
    if (logElements.length === 0) {
        // do not print infrastructure problem if the plan/test is still running
        if (result === 'running') { return }

        return [
            html`<p>Tests failed to run. See <a href="#log-links">logs</a> for more details.</p>`,
            html`
                <p>This can be an infrastructure problem, check
                <a href=https://status.testing-farm.io>status page</a>
                for known outages.</p>
            `,
            html`
                <p><a href="https://gitlab.com/testing-farm/general/-/issues">File an issue</a>
                if you think you hit a bug.</p>
            `
        ];
    }

    return html`<div id=${artifactsAnchor ?? nothing}>
        ${inlineLogs}
        ${logLinks.length > 0 ? html`<h3 id="log-links">Log links</h3><ul>${logLinks}</ul>` : null}
    </div>`;
}

function renderTmtWebLink (item, elementType, apiRequest) {
    // for now Public Ranch only
    if (!apiRequest.run?.artifacts?.startsWith('https://artifacts.dev.testing-farm.io')) { return html`` }

    // fmf data about test suite are derived from API request
    if (!apiRequest?.test?.fmf) { return html`` }

    // fmf data about test case are taken from <fmf-id> element in results.xml
    const fmfId = item.querySelector('fmf-id');
    if (elementType === 'testcase' && (!fmfId?.getAttribute('url') || !fmfId?.getAttribute('ref') ||
        !fmfId?.getAttribute('name'))) { return html`` }

    let tmtWebUrl = 'https://tmt.testing-farm.io/?';
    if (elementType === 'testsuite') {
        tmtWebUrl += `plan-url=${apiRequest.test.fmf.url}` +
            `&plan-ref=${apiRequest.test.fmf.ref}` +
            `&plan-name=${item.getAttribute('name')}` +
            ([null, '.'].includes(apiRequest.test.fmf.path) ? '' : `&plan-path=${apiRequest.test.fmf.path}`);
    } else {
        tmtWebUrl += `test-url=${fmfId?.getAttribute('url')}` +
            `&test-ref=${fmfId?.getAttribute('ref')}` +
            `&test-name=${fmfId?.getAttribute('name')}` +
            (fmfId?.getAttribute('path') === null
                ? ''
                : `&test-path=${fmfId?.getAttribute('path')}`);
    }
    return html`<a href="${tmtWebUrl}&format=html" style="text-decoration: none;" title="Inspect on tmt web">ðŸ”Ž</a>`;
}

function renderSubresults (subresults, artifactsAnchor) {
    if (!subresults || subresults.length === 0) return html``;

    const subresultsStr = [];
    const subresultsCount = subresults.length;
    let failCount = 0;
    let errorCount = 0;
    let passCount = 0;
    let skipCount = 0;
    let warnCount = 0;
    subresults.forEach(subresult => {
        switch (subresult.getAttribute('result')) {
        case 'fail': { failCount++; break }
        case 'error': { errorCount++; break }
        case 'pass': { passCount++; break }
        case 'skip': { skipCount++; break }
        case 'warn': { warnCount++; break }
        }
        const logs = subresult.querySelectorAll('logs > log');
        if (logs.length > 0) {
            // Display subresult logs inline, consistent with testcase-level logs
            logs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
            subresultsStr.push(html`
                <details>
                    <summary class="result-${subresult.getAttribute('result')}">
                        ${subresult.getAttribute('name')}
                        <span style="float:right;"><strong>${subresult.getAttribute('result')}</strong></span>
                    </summary>
                    ${renderLogs(logs, artifactsAnchor)}
                </details>`
            );
        } else {
            subresultsStr.push(html`
                <div class="subresult">
                    <monospace>
                        <div class="result-${subresult.getAttribute('result')}">
                            ${subresult.getAttribute('name')}
                            <span style="float:right;"><strong>${subresult.getAttribute('result')}</strong></span>
                        </div>
                    </monospace>
                </div>`
            );
        }
    });
    const result = failCount + errorCount === 0 ? 'pass' : (errorCount > 0 ? 'error' : 'fail');
    return html`<h3>Subresults</h3>
        <details>
            <summary class="result-${result}">
                ${subresultsCount} subresults (${[
    passCount > 0 ? `${passCount} passed` : null,
    failCount > 0 ? `${failCount} failed` : null,
    errorCount > 0 ? `${errorCount} error` : null,
    skipCount > 0 ? `${skipCount} skipped` : null,
    warnCount > 0 ? `${warnCount} warn` : null
].filter(element => element !== null).join(', ')})
            </summary>
            ${subresultsStr}
        </details>`;
}

function renderCheckSummary (checks) {
    let checkCount = 0;
    let failCount = 0;
    let errorCount = 0;
    let passCount = 0;
    let skipCount = 0;

    checks.querySelectorAll('check').forEach(check => {
        checkCount++;
        switch (check.getAttribute('result')) {
        case 'fail': { failCount++; break }
        case 'error': { errorCount++; break }
        case 'pass': { passCount++; break }
        case 'skip': { skipCount++; break }
        }
    });
    return `${checkCount} checks (${passCount} passed, ${failCount} failed, ${errorCount} error, ${skipCount} skipped)`;
}

function renderCheckList (checks, artifactsAnchor) {
    if (!checks) { return [] }
    const checksStr = [];
    const failCount = parseInt(checks.getAttribute('failures'));
    const errorCount = parseInt(checks.getAttribute('errors'));
    const result = failCount + errorCount === 0 ? 'pass' : (errorCount > 0 ? 'error' : 'fail');
    const checkObjects = checks.querySelectorAll('check');

    checkObjects.forEach(check => {
        const checkName = check.getAttribute('name');
        const checkResult = check.getAttribute('result');
        const checkEvent = check.getAttribute('event');
        const logs = check.querySelectorAll('logs > log');
        if (logs.length > 0) {
            checksStr.push(html`
                <details>
                    <summary class="result-${checkResult}">
                        ${checkName} (${checkEvent})
                        <span style="float:right;"><strong>${checkResult}</strong></span>
                    </summary>
                ${renderLogs(logs, artifactsAnchor)}
                </details>`
            );
        } else {
            checksStr.push(html`
                <div class="subresult">
                    <monospace>
                        <div class="result-${checkResult}">
                            ${checkName} (${checkEvent})
                            <span style="float:right;"><strong>${checkResult}</strong></span>
                        </div>
                    </monospace>
                </div>`
            );
        }
    });
    if (checksStr.length > 0) {
        return html`<h3>Checks</h3>
        <details ?open=${result !== 'pass'}>
            <summary class="result-${result}">
                ${renderCheckSummary(checks)}
            </summary>
            ${checksStr}
        </details>`;
    }
    return html``;
}

function renderNotes (notes) {
    if (!notes || notes.length === 0) { return html`` }
    const notesHtml = [];
    notes.forEach(note => {
        notesHtml.push(html`<li>${note.textContent}</li>`);
    });
    return html`<p>notes:</p><ul class="notes">${notesHtml}</ul>`;
}

// testsuites contain a list of testsuite, which contain a list of testcase; these have
// exactly the same structure, so we can render them with just one function
function renderTestList (doc, elementType, subElementType, showPassed, apiRequest, isPipelineRunning) {
    const res = [];
    const items = doc.querySelectorAll(elementType);
    items.forEach(item => {
        const name = item.getAttribute('name');
        const id = item.querySelector(':scope > properties > property[name=id]')?.getAttribute('value');

        // Fetch ids of all children to determine if plan should be open and visible if a test inside is linked
        const idsChildren = [];
        item.querySelectorAll('properties > property[name=id]').forEach(node => {
            idsChildren.push(node.getAttribute('value'));
        });

        let arch = null;
        let compose = null;
        let guestName = null;
        let guestRole = null;
        let isOpen = true;
        const result = normalizeResult(item.getAttribute('result'), isPipelineRunning);

        // "note" attribute is an old method of passing note, keeping it for compatibility with old requests
        const note = item.getAttribute('note');
        let notes = null;
        const guestsStr = [];
        let guestInfo = null; // displayed for testcases run in multihost pipelines
        let checks = null;
        let subresults = null;

        // Render the test suite with all tests if a test inside is linked
        const hash = window.location.hash.substring(1);
        const showPassedIteration = idsChildren.includes(hash) ? true : showPassed;

        if (!showPassedIteration && isPassed(result)) { return }

        // render artifacts anchors for top-level plans, as they can be quite far away
        const artifactsAnchor = subElementType ? 'artifacts-' + name : undefined;

        if (elementType === 'testsuite') {
            const guests = item.querySelectorAll('testsuite > guest');

            if (guests.length > 0) { // Multihost pipeline, testing environment is under <guest> elements
                guests.forEach(guest => {
                    const environment = guest.querySelector('testing-environment[name=provisioned]');
                    if (environment !== null) {
                        arch = environment.querySelector('property[name=arch]')?.getAttribute('value') ?? arch;
                        compose = environment.querySelector('property[name=compose]')?.getAttribute('value') ?? compose;
                        guestName = guest?.getAttribute('name');
                        guestRole = guest?.getAttribute('role');
                    }
                    guestsStr.push(`${guestName}${guestRole ? ` (${guestRole})` : ''}: ${arch ? `ðŸ’» ${arch}` : ''}` +
                                   `${compose ? ` ðŸ’¿ ${compose}` : ''}`);
                });
            } else { // Normal pipeline
                const environment = item.querySelector('testing-environment[name=requested]');
                if (environment != null) {
                    arch = environment.querySelector('property[name=arch]')?.getAttribute('value') ?? arch;
                    compose = environment.querySelector('property[name=compose]')?.getAttribute('value') ?? compose;
                    guestsStr.push(`${arch ? ` ðŸ’» ${arch}` : ''}${compose ? ` ðŸ’¿ ${compose}` : ''}`);
                }
            }
            isOpen = (result !== 'pass' || items.length === 1 || idsChildren.includes(hash));
        } else {
            // As we show only show not passed tests by default, we need to count them and ignore passed
            const failedTestsCount = Array.from(items).filter(i => !isPassed(i.getAttribute('result'))).length;
            isOpen = (
                id === hash || ((result !== 'pass' || items.length === 1) && failedTestsCount < tooManyTestcases)
            );
            guestName = item.querySelector('guest')?.getAttribute('name');
            guestRole = item.querySelector('guest')?.getAttribute('role');
            const serialNumber = item?.getAttribute('serial-number');
            if (guestName) {
                guestInfo = `test #${serialNumber} on ${guestName}${guestRole ? ` (${guestRole})` : ''}`;
            }
            checks = item.querySelector('checks');
            subresults = item.querySelectorAll('subresult');
            notes = item.querySelectorAll('note');
        }

        const rightSideTexts = [];
        const stage = item.getAttribute('stage');
        if (guestInfo) { rightSideTexts.push(guestInfo) }
        if (elementType === 'testsuite') { rightSideTexts.push(`${result}`) }
        if (checks && checks.getAttribute('checks') > 0) { rightSideTexts.push(`with ${renderCheckSummary(checks)}`) }
        if (item.getAttribute('time')) { rightSideTexts.push(`took ${item.getAttribute('time')} s`) }

        const detailsClass = id === hash ? 'highlight' : null;

        res.push(html`
          <details id="${id ?? nothing}" ?open="${isOpen}" class="${detailsClass ?? nothing}">
            <summary class="result-${result}">
                ${id ? html`<a class="anchor" href=#${id}>${name}</a>` : `${name}`}                
                ${renderTmtWebLink(item, elementType, apiRequest)}
                ${note ? ` (${note})` : ''}
                <monospace>
                    <span style="float:right;"><strong>${rightSideTexts.join(', ')}</strong></span><br>
                    ${guestsStr.map((guest) => html`${guest}<br>`)}
                </monospace>
                ${renderNotes(notes)}
            </summary>
            ${artifactsAnchor ? html`<p><a href="#${artifactsAnchor}">Go to Logs and Artifacts</a></p>` : null}
            ${subElementType
        ? renderTestList(item, subElementType, null, showPassedIteration, apiRequest, isPipelineRunning)
        : null}
            ${renderSubresults(subresults, artifactsAnchor)}
            ${renderCheckList(checks, artifactsAnchor)}
            ${renderLogs(item.querySelectorAll(':scope > logs > log'), artifactsAnchor, stage, result)}
          </details>`);
    });
    return res;
}

// policy functions which logs get rendered inline; this should be the most relevant ones to investigate failures

function selectInlineTestcaseLogs (testcase) {
    /* don't show successful test logs by default; matter of taste/overzealous fetching
    if (isPassed(testcase.getAttribute('result'))
        return;
    */

    let haveHtml = false;

    testcase.querySelectorAll(':scope > logs > log').forEach(log => {
        if (log.getAttribute('name').endsWith('.html')) {
            log.setAttribute(HTML_ATTR, '');
            haveHtml = true;
        }
    });

    // if there is a custom HTML viewer, don't show anything else inline
    if (haveHtml) {
        return;
    }

    testcase.querySelectorAll(':scope > logs > log').forEach(log => {
        const name = log.getAttribute('name');
        if (name === 'testout.log' /* TMT test log */ ||
            name.includes('-str_') /* STI test log */ ||
            name === 'ansible-output.txt' /* STI failed artifact install */) { log.setAttribute(SHOW_ATTR, '') }
    });
}

// always show TMT reproducer; if the setup failed, also show these logs
function selectInlineTestsuiteLogs (testsuite, failedSetup, isPipelineRunning) {
    if (!isPipelineRunning) {
        testsuite.querySelectorAll(':scope > logs > log[name="tmt-reproducer"]')
            .forEach(log => {
                console.log('fetching', log.getAttribute('href'));
                if (fetchFile(log.getAttribute('href'))) {
                    log.setAttribute(SHOW_ATTR, '');
                }
            });
    }
    if (!failedSetup) { return }

    const tmtVerboseLogs = testsuite.querySelectorAll(':scope > logs > log[name="tmt-verbose-log"]');
    tmtVerboseLogs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
    if (tmtVerboseLogs.length > 0) { return }

    const tmtLogs = testsuite.querySelectorAll(':scope > logs > log[name="tmt-log"]');
    tmtLogs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
    if (tmtLogs.length > 0) { return }

    const tmtDiscoverLogs = testsuite.querySelectorAll(':scope > logs > log[name="tmt-discover-log"]');
    tmtDiscoverLogs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
    if (tmtDiscoverLogs.length > 0) { return }

    // check for guest setup stages in reverse order, i.e. only show the most recent one
    for (const priority of ['post_artifact_installation', 'artifact_installation', 'pre_artifact_installation']) {
        const logs = testsuite.querySelectorAll(`:scope > logs > log[guest-setup-stage="${priority}"]`);
        if (logs.length > 0) {
            logs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
            break;
        }
    }
}

function selectInlineLogs (results, isPipelineRunning) {
    results.querySelectorAll('testsuite').forEach(testsuite => {
        const testcases = testsuite.querySelectorAll('testcase');
        testcases.forEach(selectInlineTestcaseLogs);
        selectInlineTestsuiteLogs(testsuite, testcases.length === 0, isPipelineRunning);
    });
}

function renderTests (resultsXml, showPassed, apiRequest, isPipelineRunning) {
    const errorReason = apiRequest?.result?.summary;
    const items = resultsXml
        ? renderTestList(
            resultsXml, 'testsuite', 'testcase', showPassed, apiRequest, isPipelineRunning)
        : [];

    // show pipeline log in case of errors
    if (apiRequest.state === 'error' || items.length === 0) {
        items.push(html`<details class="pipeline-log" open>
        <summary class="result-error">
            <a href="${pipelineLogUrl}"}>pipeline.log</a>
            <monospace>
                ${errorReason ? html`<p>âš  ${errorReason}</p>` : null}
            </monospace>
        </summary>
        <log-viewer url="${pipelineLogUrl}" />
      </details>`);
    }
    render(items, document.getElementById('main'));
}

function reloadPage () {
    // reload page only if a user scrolled to the bottom
    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
        main();
    } else {
        window.setTimeout(() => reloadPage(), 5000);
    }
}

async function main () {
    // get request ID
    const requestId = window.location.href.match(uuidRegex)?.[0];
    let apiRequestUrl = null;

    // defaulting to this request when real request cannot be fetched (e.g. when developing locally)
    let apiRequest = { state: 'complete' };

    // fetch the API request
    if (requestId !== undefined) {
        apiRequestUrl = apiUrl + `/${requestId}`;
        apiRequest = await fetchJSON(apiRequestUrl);
    }
    const resultsXmlLink = baseUrl + '/results.xml';
    document.getElementById('results-xml-src').setAttribute('href', resultsXmlLink);
    document.getElementById('results-xml-src').textContent = resultsXmlLink;

    // handle complete and error requests
    if (apiRequest.state === 'complete' || apiRequest.state === 'error') {
        // fetch results.xml
        const resultsXml = await fetchXML(resultsXmlLink);
        let overallResult = 'error'; // error when results.xml is not present (user facing error)

        // results xunit available, valid results available (might still be an error)
        if (resultsXml) {
            selectInlineLogs(resultsXml, false);
            overallResult = resultsXml.firstChild.getAttribute('overall-result');

            /* keep config hidden if there are only passed or only failed tests */
            if (!isPassed(overallResult) && resultsXml.querySelectorAll('testcase[result^="pass"]').length > 0) {
                document.getElementById('config').removeAttribute('hidden');
                document.getElementById('show_passed').addEventListener(
                    'change', ev => renderTests(resultsXml, ev.target.checked, apiRequest));
            }

            /* render and highlight a particular test/plan when a user clicks on it */
            window.addEventListener('hashchange', function () {
                renderTests(
                    resultsXml,
                    isPassed(overallResult) || document.getElementById('show_passed').checked,
                    apiRequest
                );
            });
        }

        document.getElementById('overall-result').innerHTML = overallResult;

        renderTests(resultsXml, isPassed(overallResult), apiRequest);
    } else if (apiRequest.state === 'running') {
        // fetch results.xml
        const resultsXml = await fetchXML(baseUrl + '/results.xml', { cache: 'no-store' });
        document.getElementById('overall-result').innerHTML = 'in progress';

        // results xunit available, valid results available (might still be an error)
        if (resultsXml) {
            selectInlineLogs(resultsXml, true);

            renderTests(resultsXml, true, apiRequest, true);
        } else {
            const pipelineLog = await fetchFile(pipelineLogUrl, { cache: 'no-store' });
            render(html`<pre>${unsafeHTML(ansiUp.ansi_to_html(pipelineLog))}</pre>`, document.getElementById('main'));

            // reload in 5 seconds, what matches the pipeline.log refresh tick (5s)
            window.setTimeout(() => reloadPage(), 5000);

            // scroll to bottom of the page, if scrolled to the bottom
            window.scrollTo(0, document.body.scrollHeight);
        }
    } else if (apiRequest.state === 'queued') {
        // set the result of the request to `in progress`
        document.getElementById('overall-result').innerHTML = 'in progress';

        // prevent caching the response of pipeline.log
        const pipelineLog = await fetchFile(pipelineLogUrl, { cache: 'no-store' });
        render(html`<pre>${unsafeHTML(ansiUp.ansi_to_html(pipelineLog))}</pre>`, document.getElementById('main'));

        // reload in 5 seconds, what matches the pipeline.log refresh tick (5s)
        window.setTimeout(() => reloadPage(), 5000);

        // scroll to bottom of the page, if scrolled to the bottom
        window.scrollTo(0, document.body.scrollHeight);
    } else if (apiRequest.state === 'cancel-requested' || apiRequest.state === 'canceled') {
        // set the result of the request to `canceled`
        document.getElementById('overall-result').innerHTML = 'canceled';

        // Render a plain note that the request was canceled
        render(html`<pre>Request was canceled on user request.</pre>`, document.getElementById('main'));
    }

    // show results-junit.xml in header if it exists
    if (await fetchHeader(baseUrl + '/results-junit.xml')) {
        document.getElementById('download-junit-separator').removeAttribute('hidden');
        document.getElementById('download-junit').removeAttribute('hidden');
        document.getElementById('download-junit').setAttribute('href', baseUrl + '/results-junit.xml');
    }

    // extract request UUID from current URL; show API request when present
    if (apiRequestUrl) {
        document.getElementById('api-request-separator').removeAttribute('hidden');
        document.getElementById('api-request').removeAttribute('hidden');
        document.getElementById('api-request').setAttribute('href', apiRequestUrl);
    }

    document.getElementById('pipeline-log').removeAttribute('hidden');
    document.getElementById('pipeline-log').setAttribute('href', pipelineLogUrl);

    document.getElementById('docs-separator').removeAttribute('hidden');
    document.getElementById('docs').removeAttribute('hidden');
    document.getElementById('docs').setAttribute('href', docsUrl);

    // Function to check for next.html and enable the switcher
    async function enableNewUISwitcher () {
        try {
            const response = await fetch('next.html', { method: 'HEAD' });
            if (response.ok) {
                const switchToNewUILink = document.getElementById('switchToNewUI');
                const switchToNewUISeparator = document.getElementById('switchToNewUISeparator');

                if (switchToNewUILink && switchToNewUISeparator) {
                    switchToNewUILink.removeAttribute('hidden');
                    switchToNewUISeparator.removeAttribute('hidden');

                    switchToNewUILink.addEventListener('click', (event) => {
                        event.preventDefault();
                        localStorage.setItem('oculusUIVersion', 'next');
                        window.location.href = baseUrl === '.' ? 'next.html' : `next.html?url=${baseUrl}`;
                    });
                }
            }
        } catch (error) {
            console.warn('Could not check for next.html: ', error);
        }
    }

    // Call the function to enable switcher after other initializations
    enableNewUISwitcher();
}

main();
</script>

</html>
