<!DOCTYPE html>
<html lang="en">
<head>
  <title>Testing Farm Result</title>
  <meta charset="utf-8">

  <style>
    header { display: flex; }
    header h1 { margin-left: 1em; }
    .stretch { flex: auto; }

    details {
      padding: 1ex;
      margin: 3ex;
      background-color: #F2F2F2;
      box-shadow: 2px 2px 2px lightgrey;
    }
    details > summary { padding: 1.5em; }

    /* nested details are testcases in a testsuite */
    details details { background-color: white; }
    details details > summary { padding: 0.5em; }

    .result-pass, .result-passed { background-color: lightgreen; }
    .result-failed, .result-failure, .result-needs_inspection { background-color: #ff4d4d; }
    .result-error, .result-undefined { background-color: darkorange; }
    .result-skipped { background-color: lightgrey; }
  </style>
</head>

<body>
  <header>
    <img src="https://assets.gitlab-static.net/uploads/-/system/group/avatar/5515434/tft-logo.png"
        width="64" height="64" alt="Testing Farm Logo"/>
    <h1 class="stretch" id="overall-result"></h1>
    <a href="https://gitlab.com/testing-farm/general/-/issues">Feedback and issues about this page</a>
  </header>

  <main id="main" />
</body>

<script type="module">
import {LitElement, html, css, render } from 'https://cdn.jsdelivr.net/gh/lit/dist@2/core/lit-core.min.js';

const SHOW_ATTR = '_show'; /* marks logs which are shown inline */

async function fetchFile(url) {
    try {
        const response = await fetch(url);
        if (response.ok)
            return await response.text();
        else
            console.warn('Failed to fetch', url, ':', response.status, response.statusText);
    } catch (error) {
        console.warn('Failed to fetch', url, ':', error);
    }
}

async function fetchXML(url) {
    const raw = await fetchFile(url);
    if (raw)
        return new DOMParser().parseFromString(raw, 'text/xml');
}

// custom component: dynamically load a log file/directory and show it inline
class LogViewer extends LitElement {
    static properties = {
        url: {type: String},
        _contents: {type: String, state: true},
    };

    // load the URL on first render
    firstUpdated(changedProperties) {
        if(changedProperties.has('url'))
            fetchFile(this.url).then(text => {
                // is this a directory index? if so, load all of its *.txt files and concatenate
                if (text.indexOf('<head><title>Index of ') >= 0) {
                    const indexDoc = new DOMParser().parseFromString(text, 'text/html');
                    const fetches = [];
                    indexDoc.querySelectorAll('a[href*=".txt"]').forEach(link =>
                        fetches.push(fetchFile(this.url + '/' + link.getAttribute('href'))));
                    Promise.all(fetches).then(texts => {this._contents = texts.join('\n\n')});
                } else {
                    // plain file
                    this._contents = text;
                }
            });
    }

    render() {
        return html`<pre class="log-viewer">${this._contents ?? 'Loading...'}</pre>`;
    }

    static styles = css`
        pre {
            background-color: #E0E0E0;
            padding: 0.5em;
            overflow: auto;
            max-height: 70em;
        }`;
}

customElements.define('log-viewer', LogViewer);

function renderLogs(logElements) {
    const logLinks = [];
    const inlineLogs = [];
    logElements.forEach(log => {
        let name = log.getAttribute('name');
        const href = log.getAttribute('href');
        // HACK: results.xml should have unique names; fix that, and then clean this up
        const setup_stage = log.getAttribute('guest-setup-stage');
        if (setup_stage && name == 'guest setup')
            name = setup_stage;
        if (log.hasAttribute(SHOW_ATTR))
            inlineLogs.push(html`<h3><a href=${href}>${name}</a></h3>
                                 <log-viewer url=${href} />`);
        else
            logLinks.push(html`<li><a href=${href}>${name}</a></li>`);
    });

    // no logs means an infrastructure problem, provide some hints how to handle the situation
    if (logElements.length == 0) {
        return [
            html`<p>Tests failed to run. See <a href=${baseUrl}pipeline.log>pipeline.log</a> for details.</p>`,
            html`<p>This can be an infrastructure problem, check <a href=https://status.testing-farm.io>status page</a> for known outages.</p>`,
            html`<p><a href="https://gitlab.com/testing-farm/general/-/issues">File an issue</a> if you think you hit a bug.</p>`
        ];
    }

    return [
        logLinks.length > 0 ? html`<h3>Log links</h3><ul>${logLinks}</ul>` : null,
        inlineLogs
    ];
}

// testsuites contain a list of testsuite, which contain a list of testcase; these have
// exactly the same structure, so we can render them with just one function
function renderTestList(doc, elementType, subElementType) {
    const res = [];
    doc.querySelectorAll(elementType).forEach(item => {
        const result = item.getAttribute('result');
        res.push(html`
          <details ?open=${result != 'passed'}>
            <summary class="result-${result}">${item.getAttribute('name')}</summary>
            ${renderLogs(item.querySelectorAll(':scope > logs > log'))}
            ${subElementType ? renderTestList(item, subElementType) : null}
          </details>`);
    });
    return res;
}

// policy functions which logs get rendered inline; this should be the most relevant ones to investigate failures

function selectInlineTestcaseLogs(testcase) {
    /* don't show successful test logs by default; matter of taste/overzealous fetching
    if (testcase.getAttribute('result').indexOf('pass') >= 0)
        return;
    */

    testcase.querySelectorAll(':scope > logs > log').forEach(log => {
        const name = log.getAttribute('name');
        if (name == 'testout.log' /* TMT test log */ ||
            name.indexOf('-str_') > 0 /* STI test log */ ||
            name == 'ansible-output.txt' /* STI failed artifact install */)
            log.setAttribute(SHOW_ATTR, '');
    });
}

// always show TMT reproducer; if the setup failed, also show these logs
function selectInlineTestsuiteLogs(testsuite, failedSetup) {
    testsuite.querySelectorAll(':scope > logs > log[name="tmt-reproducer"]')
        .forEach(log => log.setAttribute(SHOW_ATTR, ''));
    if (!failedSetup)
        return;

    // check for guest setup stages in reverse order, i.e. only show the most recent one
    for (let priority of ['post_artifact_installation', 'artifact_installation', 'pre_artifact_installation']) {
        const logs = testsuite.querySelectorAll(`:scope > logs > log[guest-setup-stage="${priority}"]`);
        if (logs.length > 0) {
            logs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
            break;
        }
    }
}

function selectInlineLogs(results) {
    results.querySelectorAll('testsuite').forEach(testsuite => {
        const testcases = testsuite.querySelectorAll('testcase');
        testcases.forEach(selectInlineTestcaseLogs);
        selectInlineTestsuiteLogs(testsuite, testcases.length == 0);
    });
}

// allow user to point to a different result URL, mostly for testing
const baseUrl = new URLSearchParams(window.location.search).get('url') ?? '.';
// first try to fetch results.xml; if we have it, test is done
const resultsXml = await fetchXML(baseUrl + '/results.xml');
if (resultsXml) {
    selectInlineLogs(resultsXml);
    document.getElementById('overall-result').innerHTML = resultsXml.firstChild.getAttribute('overall-result');
    render(renderTestList(resultsXml, 'testsuite', 'testcase'), document.getElementById('main'));
} else {
    // no results.xml yet, fall back to "in progress" and showing pipeline.log
    document.getElementById('overall-result').innerHTML = 'in progress';
    const pipelineLog = await fetchFile(baseUrl + '/pipeline.log');
    render(html`<pre>${pipelineLog}</pre>`, document.getElementById('main'));
}
</script>

</html>
