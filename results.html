<!DOCTYPE html>
<html lang="en">
<head>
  <title>Testing Farm Result</title>
  <meta charset="utf-8">

  <style>
    header {
        display: flex;
        align-items: center;
        gap: 2ex;
    }
    .stretch { flex: auto; }
    #config {
        padding: 1em 0.5em;
        border: lightgray;
        border-width: 1px;
        border-style: solid;
        box-shadow: 2px 2px 2px lightgrey;
    }

    details {
      padding: 1ex;
      margin: 3ex;
      background-color: #F2F2F2;
      box-shadow: 2px 2px 2px lightgrey;
    }
    details > summary { padding: 1.5em; }
    details > summary > p {
        margin-bottom: 0;
        font-weight: bold;
    }

    /* nested details are testcases in a testsuite */
    details details { background-color: white; }
    details details > summary { padding: 0.5em; }

    .result-pass { background-color: lightgreen; }
    .result-fail { background-color: #ff4d4d; }
    .result-info { background-color: lightblue; }
    .result-skip { background-color: lightgrey; }
    .result-error { background-color: darkorange; }

    iframe.html-artifact { height: 80vh; }
  </style>
</head>

<body>
  <header>
    <img src="https://assets.gitlab-static.net/uploads/-/system/group/avatar/5515434/tft-logo.png"
        width="64" height="64" alt="Testing Farm Logo"/>
    <h1 id="overall-result"></h1>
    <div id="config" hidden>
        <input id="show_passed" type="checkbox" />
        <label for="show_passed">Show passed tests</label>
    </div>
    <div class="stretch"></div>
    <a id="docs" hidden>Docs</a>
    <span id="docs-separator" hidden>|</span>
    <a id="api-request" hidden>API request</a>
    <span id="api-request-separator" hidden>|</span>
    <a id="pipeline-log">Pipeline log</a>
    <span id="pipeline-log-separator">|</span>
    <a href="https://gitlab.com/testing-farm/oculus/-/issues">Issues for this page</a>
    <span id="download-junit-separator" hidden>|</span>
    <a id="download-junit" download hidden>Download JUnit</a>
  </header>

  <main id="main" />
</body>

<script type="module">
import { LitElement, html, css, render, nothing } from 'https://cdn.jsdelivr.net/gh/lit/dist@2/core/lit-core.min.js';

const SHOW_ATTR = '_show'; /* marks logs which are shown inline */
const HTML_ATTR = '_html'; /* marks HTML artifacts which are shown inline */

const isPassed = result => result.includes('pass');

// HACK: the request API url should be read from some metadata file instead
const apiUrl = 'https://api.dev.testing-farm.io/v0.1/requests';

const uuidRegex = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/;

// allow user to point to a different result URL, mostly for testing
const baseUrl = new URLSearchParams(window.location.search).get('url') ?? '.';

// pipeline log, the main log of the worker
const pipelineLogUrl = `${baseUrl}/pipeline.log`;

// link to the user docs
const docsUrl = 'https://docs.testing-farm.io/general/0.1/index.html';

// HACK: Until TFT-1687 is implemented.
// unify the variations of "pass", "passed", "failed", "failure", etc. to the defined .result-.. classes
function normalizeResult (result) {
    if (!result) {
        return 'error';
    }
    const lower = result.toLowerCase();
    if (lower.includes('pass')) { return 'pass' }
    if (lower.includes('fail') || lower.includes('inspection')) { return 'fail' }
    if (lower.includes('skip')) { return 'skip' }
    if (lower.includes('info')) { return 'info' }
    // treat other values like "error", "undefined", unknown as generic error
    return 'error';
}

async function fetchFile (url, options) {
    try {
        const response = await fetch(url, options);
        if (response.ok) {
            return await response.text();
        } else {
            console.warn('Failed to fetch', url, ':', response.status, response.statusText);
        }
    } catch (error) {
        console.warn('Failed to fetch', url, ':', error);
    }
}

async function fetchHeader (url) {
    try {
        const response = await fetch(url, { method: 'HEAD' });
        if (response.ok) { return true }
    } catch (error) {
        console.warn('Failed to fetch header', url, ':', error);
    }
    return false;
}

async function fetchJSON (url) {
    try {
        const response = await fetch(url);
        if (response.ok) {
            return await response.json();
        } else {
            console.warn('Failed to fetch', url, ':', response.status, response.statusText);
        }
    } catch (error) {
        console.warn('Failed to fetch', url, ':', error);
    }
}

async function fetchXML (url) {
    const raw = await fetchFile(url);
    if (raw) { return new DOMParser().parseFromString(raw, 'text/xml') }
}

// custom component: dynamically load a log file/directory and show it inline
class LogViewer extends LitElement {
    static properties = {
        url: { type: String },
        _contents: { type: String, state: true }
    };

    updated (changedProperties) {
        if (changedProperties.has('url')) {
            fetchFile(this.url).then(text => {
                // is this a directory index? if so, load all of its *.txt files and concatenate
                if (text?.includes('<title>Index of ')) {
                    const indexDoc = new DOMParser().parseFromString(text, 'text/html');
                    const fetches = [];
                    indexDoc.querySelectorAll('a[href*=".txt"]').forEach(link =>
                        fetches.push(fetchFile(this.url + '/' + link.getAttribute('href'))));
                    Promise.all(fetches).then(texts => { this._contents = texts.join('\n\n') });
                } else {
                // plain file
                    this._contents = text;
                }
            });
        }
    }

    render () {
        return html`<pre class="log-viewer">${this._contents ?? 'Loading...'}</pre>`;
    }

    static styles = css`
        pre {
            background-color: #E0E0E0;
            padding: 0.5em;
            overflow: auto;
            max-height: 70em;
        }`;
}

customElements.define('log-viewer', LogViewer);

function renderLogs (logElements, artifactsAnchor) {
    const logLinks = [];
    const inlineLogs = [];
    logElements.forEach(log => {
        let name = log.getAttribute('name');
        const href = log.getAttribute('href');
        // HACK: results.xml should have unique names; fix that, and then clean this up
        const setupStage = log.getAttribute('guest-setup-stage');
        if (setupStage && name === 'guest setup') { name = setupStage }
        if (log.hasAttribute(SHOW_ATTR)) {
            inlineLogs.push(html`<h3><a href=${href}>${name}</a></h3>
                                 <log-viewer url=${href} />`);
        } else if (log.hasAttribute(HTML_ATTR)) {
            inlineLogs.push(html`<h3><a href=${href}>${name}</a></h3>
                                 <iframe class="html-artifact" title=${name} src=${href} width="100%" />`);
        } else {
            logLinks.push(html`<li><a href=${href}>${name}</a></li>`);
        }
    });

    // no logs means an infrastructure problem, provide some hints how to handle the situation
    if (logElements.length === 0) {
        return [
            html`<p>Tests failed to run. See <a href=${pipelineLogUrl}></a> for details.</p>`,
            html`
                <p>This can be an infrastructure problem, check
                <a href=https://status.testing-farm.io>status page</a>
                for known outages.</p>
            `,
            html`
                <p><a href="https://gitlab.com/testing-farm/general/-/issues">File an issue</a>
                if you think you hit a bug.</p>
            `
        ];
    }

    return html`<div id=${artifactsAnchor ?? nothing}>
        ${inlineLogs}
        ${logLinks.length > 0 ? html`<h3>Log links</h3><ul>${logLinks}</ul>` : null}
    </div>`;
}

// testsuites contain a list of testsuite, which contain a list of testcase; these have
// exactly the same structure, so we can render them with just one function
function renderTestList (doc, elementType, subElementType, showPassed, errorReason) {
    const res = [];
    const items = doc.querySelectorAll(elementType);
    items.forEach(item => {
        const name = item.getAttribute('name');
        const result = normalizeResult(item.getAttribute('result'));
        if (!showPassed && isPassed(result)) { return }

        // render artifacts anchors for top-level plans, as they can be quite far away
        const artifactsAnchor = subElementType ? 'artifacts-' + name : undefined;

        res.push(html`
          <details ?open=${result !== 'pass' || items.length === 1}>
            <summary class="result-${result}">
                ${name}
                ${result === 'error' && errorReason ? html`<p>âš  ${errorReason}</p>` : null}
            </summary>
            ${artifactsAnchor ? html`<p><a href="#${artifactsAnchor}">Go to Logs and Artifacts</a></p>` : null}
            ${subElementType ? renderTestList(item, subElementType, null, showPassed, null) : null}
            ${renderLogs(item.querySelectorAll(':scope > logs > log'), artifactsAnchor)}
          </details>`);
    });
    return res;
}

// policy functions which logs get rendered inline; this should be the most relevant ones to investigate failures

function selectInlineTestcaseLogs (testcase) {
    /* don't show successful test logs by default; matter of taste/overzealous fetching
    if (isPassed(testcase.getAttribute('result'))
        return;
    */

    let haveHtml = false;

    testcase.querySelectorAll(':scope > logs > log').forEach(log => {
        if (log.getAttribute('name').endsWith('.html')) {
            log.setAttribute(HTML_ATTR, '');
            haveHtml = true;
        }
    });

    // if there is a custom HTML viewer, don't show anything else inline
    if (haveHtml) {
        return;
    }

    testcase.querySelectorAll(':scope > logs > log').forEach(log => {
        const name = log.getAttribute('name');
        if (name === 'testout.log' /* TMT test log */ ||
            name.includes('-str_') /* STI test log */ ||
            name === 'ansible-output.txt' /* STI failed artifact install */) { log.setAttribute(SHOW_ATTR, '') }
    });
}

// always show TMT reproducer; if the setup failed, also show these logs
function selectInlineTestsuiteLogs (testsuite, failedSetup) {
    testsuite.querySelectorAll(':scope > logs > log[name="tmt-reproducer"]')
        .forEach(log => log.setAttribute(SHOW_ATTR, ''));
    if (!failedSetup) { return }

    const tmtLogs = testsuite.querySelectorAll(':scope > logs > log[name="tmt-log"]');
    tmtLogs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
    if (tmtLogs.length > 0) { return }

    // check for guest setup stages in reverse order, i.e. only show the most recent one
    for (const priority of ['post_artifact_installation', 'artifact_installation', 'pre_artifact_installation']) {
        const logs = testsuite.querySelectorAll(`:scope > logs > log[guest-setup-stage="${priority}"]`);
        if (logs.length > 0) {
            logs.forEach(log => log.setAttribute(SHOW_ATTR, ''));
            break;
        }
    }
}

function selectInlineLogs (results) {
    results.querySelectorAll('testsuite').forEach(testsuite => {
        const testcases = testsuite.querySelectorAll('testcase');
        testcases.forEach(selectInlineTestcaseLogs);
        selectInlineTestsuiteLogs(testsuite, testcases.length === 0);
    });
}

function renderTests (resultsXml, showPassed, errorReason) {
    const items = renderTestList(resultsXml, 'testsuite', 'testcase', showPassed, errorReason);

    // show pipeline log if overall state is "error"
    const overallResult = resultsXml.firstChild.getAttribute('overall-result');
    if (overallResult === 'error') {
        items.push(html`<details class="pipeline-log" open>
            <summary class="result-error"><a href="${pipelineLogUrl}"}>pipeline.log</a></summary>
            <log-viewer url="${pipelineLogUrl}" />
          </details>`);
    }

    render(items, document.getElementById('main'));
}

function reloadPage () {
    // reload page only if a user scrolled to the bottom
    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
        main();
    } else {
        window.setTimeout(() => reloadPage(), 5000);
    }
}

async function main () {
    // get request ID
    const requestId = window.location.href.match(uuidRegex)?.[0];
    const apiRequestUrl = apiUrl + `/${requestId}`;

    // first try to fetch results.xml; if we have it, test is done
    const resultsXml = await fetchXML(baseUrl + '/results.xml');

    if (resultsXml) {
        // fetch the possible error reason
        const apiRequest = await fetchJSON(apiRequestUrl);
        const errorReason = apiRequest?.result?.summary;

        selectInlineLogs(resultsXml);
        const overallResult = resultsXml.firstChild.getAttribute('overall-result');
        document.getElementById('overall-result').innerHTML = overallResult;

        /* keep config hidden if there are only passed or only failed tests */
        if (!isPassed(overallResult) && resultsXml.querySelectorAll('testcase[result^="pass"]').length > 0) {
            document.getElementById('config').removeAttribute('hidden');
            document.getElementById('show_passed').addEventListener(
                'change', ev => renderTests(resultsXml, ev.target.checked, errorReason));
        }
        renderTests(resultsXml, isPassed(overallResult), errorReason);
    } else {
        // no results.xml yet, fall back to "in progress" and showing pipeline.log
        document.getElementById('overall-result').innerHTML = 'in progress';
        // prevent caching the response of pipeline.log
        const pipelineLog = await fetchFile(pipelineLogUrl, { cache: 'no-store' });
        render(html`<pre>${pipelineLog}</pre>`, document.getElementById('main'));
        // reload in 5 seconds, what matches the pipeline.log refresh tick (5s)
        window.setTimeout(() => reloadPage(), 5000);
        // scroll to bottom of the page, if scrolled to the bottom
        window.scrollTo(0, document.body.scrollHeight);
    }

    // show results-junit.xml in header if it exists
    if (await fetchHeader(baseUrl + '/results-junit.xml')) {
        document.getElementById('download-junit-separator').removeAttribute('hidden');
        document.getElementById('download-junit').removeAttribute('hidden');
        document.getElementById('download-junit').setAttribute('href', baseUrl + '/results-junit.xml');
    }

    // extract request UUID from current URL; show API request when present
    if (requestId) {
        document.getElementById('api-request-separator').removeAttribute('hidden');
        document.getElementById('api-request').removeAttribute('hidden');
        document.getElementById('api-request').setAttribute('href', apiRequestUrl);
    }

    document.getElementById('pipeline-log-separator').removeAttribute('hidden');
    document.getElementById('pipeline-log').removeAttribute('hidden');
    document.getElementById('pipeline-log').setAttribute('href', pipelineLogUrl);

    document.getElementById('docs-separator').removeAttribute('hidden');
    document.getElementById('docs').removeAttribute('hidden');
    document.getElementById('docs').setAttribute('href', docsUrl);
}

main();
</script>

</html>
